<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Match History</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <h1>Match History</h1>

    <!-- Dropdown to select players -->
    <label for="player-select">Select Player:</label>
    <select id="player-select">
      <option value="all">All Players</option>
    </select>

    <!-- Win rate display -->
    <div id="win-rate"></div>

    <!-- Table to display match history -->
    <table id="match-history">
      <thead>
        <tr>
          <th>Player</th>
          <th>Map</th>
          <th>Duration</th>
          <th>Opponent</th>
          <th>Outcome</th>
        </tr>
      </thead>
      <tbody>
        <!-- Rows will be dynamically generated -->
      </tbody>
    </table>

    <script>
      let playerWins = {};
      let playerMatches = {};

      // Load player data to populate the dropdown
      async function loadPlayerData() {
        const playerData = await fetch("player-data.json").then((res) =>
          res.json()
        );
        const playerSelect = document.getElementById("player-select");
        playerData.forEach((player) => {
          const option = document.createElement("option");
          option.value = player.id;
          option.textContent = `ID: ${player.id} | ${player.username}`;
          playerSelect.appendChild(option);
        });
        return playerData;
      }

      // Load match history and populate the table
      async function loadMatchHistory(playerData) {
        const matchHistory = await fetch("match-history.json").then((res) =>
          res.json()
        );
        const playerMap = Object.fromEntries(
          playerData.map((player) => [player.id, player.username])
        );

        // Initially show all matches
        updateTable(matchHistory, playerMap, null);

        // Add event listener for dropdown filtering
        const playerSelect = document.getElementById("player-select");
        playerSelect.addEventListener("change", () => {
          const selectedPlayerId =
            playerSelect.value === "all" ? null : Number(playerSelect.value);
          updateTable(matchHistory, playerMap, selectedPlayerId);
        });
      }

      // Update the match table based on filters
      function updateTable(matches, playerMap, filterPlayerId) {
        const tableBody = document.querySelector("#match-history tbody");
        const winRateContainer = document.getElementById("win-rate");
        tableBody.innerHTML = ""; // Clear existing rows
        winRateContainer.textContent = ""; // Clear win rate

        // Reset tracking variables
        playerWins = {};
        playerMatches = {};

        // Sort matches by match_id (ascending order)
        matches.sort((a, b) => a.id - b.id);

        matches.forEach((match) => {
          // Only show matches involving the selected player (or all matches)
          const playerInvolved =
            filterPlayerId === null ||
            match.player_id === filterPlayerId ||
            match.opponent_id === filterPlayerId;

          if (playerInvolved) {
            const row = document.createElement("tr");

            // Determine player and opponent names
            const playerName = playerMap[match.player_id];
            const opponentName = playerMap[match.opponent_id];

            // Track wins and matches for win rate calculation
            if (filterPlayerId) {
              // Check different scenarios for tracking wins
              if (filterPlayerId === match.player_id) {
                // Direct match tracking
                playerMatches[filterPlayerId] = 
                  (playerMatches[filterPlayerId] || 0) + 1;
                
                if (match.outcome === 1) {
                  playerWins[filterPlayerId] = 
                    (playerWins[filterPlayerId] || 0) + 1;
                }
              } else if (filterPlayerId === match.opponent_id) {
                // Flipped match tracking
                playerMatches[filterPlayerId] = 
                  (playerMatches[filterPlayerId] || 0) + 1;
                
                if (match.outcome === 0) {
                  playerWins[filterPlayerId] = 
                    (playerWins[filterPlayerId] || 0) + 1;
                }
              }
            }

            // Ensure that the selected player always appears first
            let firstColumnName, secondColumnName, displayOutcome, isPlayerPerspective;
            if (filterPlayerId) {
              if (filterPlayerId === match.player_id) {
                // Match from player's perspective
                firstColumnName = playerName;
                secondColumnName = opponentName;
                displayOutcome = formatOutcome(
                  match.outcome, 
                  true, 
                  playerName, 
                  opponentName
                );
                isPlayerPerspective = true;
              } else {
                // Match from opponent's perspective
                firstColumnName = opponentName;
                secondColumnName = playerName;
                // Invert the outcome when perspective is flipped
                const invertedOutcome = match.outcome === 1 ? 0 : 
                                        (match.outcome === 0 ? 1 : match.outcome);
                displayOutcome = formatOutcome(
                  invertedOutcome, 
                  true, 
                  opponentName, 
                  playerName
                );
                isPlayerPerspective = false;
              }
            } else {
              // All players view
              firstColumnName = playerName;
              secondColumnName = opponentName;
              displayOutcome = formatOutcome(
                match.outcome, 
                true, 
                playerName, 
                opponentName
              );
              isPlayerPerspective = true;
            }

            // Format the row
            row.innerHTML = `
                <td>${firstColumnName}</td>
                <td>${match.map}</td>
                <td>${isNaN(match.time) ? "-" : formatDuration(match.time)}</td>
                <td>${secondColumnName}</td>
                <td>${displayOutcome}</td>
            `;

            tableBody.appendChild(row);
          }
        });

        // Update win rate display if filtering by a specific player
        if (filterPlayerId) {
          displayWinRate(filterPlayerId);
        }
      }

      // Display win rate for the selected player
      function displayWinRate(playerId) {
        const winRateContainer = document.getElementById("win-rate");
        const wins = playerWins[playerId] || 0;
        const totalMatches = playerMatches[playerId] || 0;
        const winRate = totalMatches > 0 ? (wins / totalMatches) * 100 : 0;

        winRateContainer.textContent = `Win Rate: ${winRate.toFixed(
          2
        )}% (${wins} wins out of ${totalMatches} matches)`;
      }

      // Format duration from seconds to MM:SS
      function formatDuration(seconds) {
        if (isNaN(seconds)) return "-"; // Handle NaN durations
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${String(minutes).padStart(2, "0")}:${String(
          remainingSeconds
        ).padStart(2, "0")}`;
      }

      // Format outcome based on the perspective of the player
      function formatOutcome(outcome, isPlayer, playerName, opponentName) {
        if (outcome === 1) return isPlayer ? "Win" : `${opponentName} won`;
        if (outcome === 0) return isPlayer ? "Lose" : `${playerName} won`;
        return "Draw";
      }

      // Initialize page content
      document.addEventListener("DOMContentLoaded", async () => {
        const playerData = await loadPlayerData();
        await loadMatchHistory(playerData);
      });
    </script>
  </body>
</html>